import probs

//population so that number of s + i + r = 1
record Population(susceptible: Double, infected: Double, recovered: Double)

//multiply s,i,r parts of population with transition probabilitys to get new state of population
def progression(p: Population): Population = {
  p match {
    case Population(s, i, r) =>
      val s1 = 0.5 * s
      val i1 = 0.3 * i + 0.5 * s + 0.1 * r 
      val r1 =  0.9 * r + 0.7 * i
      return Population(s1, i1, r1)
  }
}

//testing the popultaion(like covid test)
def test(p: Population, pr: Double): Unit / Observe = {
  p match {
    case Population(s, i, r) =>
      val mean = i 
      val sampleSize = 100.0
      do Observe(pr, Beta(mean, sampleSize))
  }
}

//approximate next state of population based on current state
def step(p0: Population, pr1: Double): Population /  Observe = {
  val p1 = progression(p0)
  test(p1, pr1)
  return p1
}

def main() = {
  val start = timestamp()
  
  println("testing with rejection Sampling")
  handleLimitEmit[Population, Unit](1){rejectionSampling[Population]{
    val init = Population(0.7, 0.2, 0.1)
    step(init, 0.3)
  }}
  val t0 = timestamp()
  println(t0 - start)

  println("testing with slice Sampling")
  //kommt be beiden gleiches raus weil progressen nicht probabilistische operationen
  handleLimitEmit[Population, Unit](2){sliceSampling[Population]{
    val init = Population(0.7, 0.2, 0.1)
    step(init, 0.3)
  }}
  val t1 = timestamp()
  println(t1 - t0)
  println("\n")

  handleLimitEmit[Population, Unit](1){sliceSampling[Population]{
    var nextPop = Population(0.7, 0.2, 0.1)
    var nextpr = 0.4
    var m = 5

    while(m > 0){
      nextPop = step(nextPop, nextpr)
      val noise = do Sample(Gaussian(0.0, 0.01))
      var nextpr1 = nextpr + noise
      if(not(nextpr1 < 0.0 || nextpr1 > 1.0)){nextpr = nextpr1}

      println(nextPop)
      m = m - 1
    }
    return nextPop
  }}
  val t2 = timestamp()
  println(t2 - t1)

  println("\ntesting with Metropolis Hastings")

  handleLimitEmit[Population, Unit](1){metropolisHastings[Population]{
    var nextPop = Population(0.7, 0.2, 0.1)
    var nextpr = 0.4
    var m = 5

    while(m > 0){
      nextPop = step(nextPop, nextpr)
      val noise = do Sample(Gaussian(0.0, 0.01))
      var nextpr1 = nextpr + noise
      if(not(nextpr1 < 0.0 || nextpr1 > 1.0)){nextpr = nextpr1}

      println(nextPop)
      m = m - 1
    }
    return nextPop
  }}
  val t3 = timestamp()
  println(t3 - t2)

  println("\ntesting with metropolis Hastings Single Site")
  handleLimitEmit[Population, Unit](1){metropolisHastingsSingleSite[Population]{
    var nextPop = Population(0.7, 0.2, 0.1)
    var nextpr = 0.4
    var m = 5

    while(m > 0){
      nextPop = step(nextPop, nextpr)
      val noise = do Sample(Gaussian(0.0, 0.01))
      var nextpr1 = nextpr + noise
      if(not(nextpr1 < 0.0 || nextpr1 > 1.0)){nextpr = nextpr1}

      println(nextPop)
      m = m - 1
    }
    return nextPop
  }}
  val t4 = timestamp()
  println(t4 - t3)
}