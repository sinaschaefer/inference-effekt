import probs

//population so that number of s + i + r = 1
record Population(susceptible: Double, infected: Double, recovered: Double)

//multiply s,i,r parts of population with transition probabilitys to get new state of population
def progression(p: Population): Population = {
  p match {
    case Population(s, i, r) =>
      val s1 = 0.5 * s
      val i1 = 0.3 * i + 0.5 * s + 0.1 * r 
      val r1 =  0.9 * r + 0.7 * i
      return Population(s1, i1, r1)
  }
}

//testing the popultaion(like covid test)
def test(p: Population, pr: Double): Unit / Observe = {
  p match {
    case Population(s, i, r) =>
      val mean = i 
      val sampleSize = 100
      do Observe(pr, Beta(i, 100.0))
  }
}

//approximate next state of population based on current state
def step(p0: Population, pr1: Double): Population / {Sample, Observe} = {
  val p1 = progression(p0)
  test(p1, pr1)
  return p1
}

def main() = {
  println(progression(Population(0.7, 0.2, 0.1))) //result: Population(0.35, 0.42, 0.23)

  handleLimitEmit[Population, Unit](1){handleRandom{handleSample{sliceSampling[Population]{handleObserve{
    val init = Population(0.7, 0.2, 0.1)
    step(init, 0.3)
  }}}}}
}