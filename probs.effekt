module probs 
import immutable/list

extern pure def pow(x: Double, y: Double): Double = "Math.pow(x, y)"
extern pure def gamma(n: Double): Double = "Math.gamma(n)"

effect Sample(dist: Distribution): Double
effect Observe(value: Double, dist: Distribution): Unit
effect Random(): Double
effect Weight(prob: Probability): Unit
interface Emit[A] {
  def emit(element: A): Unit
}

type Distribution{
  Gaussian(mean: Double, variance: Double)
  Uniform(lower: Double, upper: Double)
  Beta(alpha: Double, beta: Double)
}
type Probability = Double
type Trace = List[Double]

// draws a Sample from a Distribution
def draw(dist: Distribution): Double / Random = {
  dist match {
    case Gaussian(mean, variance) => 
      val u1 = do Random();
      val u2 = do Random();

      val sigma = variance

      //box-muller-Methode
      val mag = sigma * sqrt(-2.0 * log(u1))
      val z0 = mag * cos(2.0 * PI * u2) 
      //val z1 = mag * sin(2.0 * PI * u2)

      return z0 + mean
    
    case Uniform(lower, upper) => 
      val x = do Random()
      return (lower + x * upper)
    
    case Beta(alpha, beta) => 
      val mean = 0.5
      val variance = 1.0 /(4.0 * ((2.0 * alpha) + 1.0))
      return draw(Gaussian(mean, variance))
  } 
}

//probability density function for Gaussian distribution
def density(value: Double, dist: Distribution): Double = {
  dist match {
    case Gaussian(mean, variance) =>
      val density = 1.0/(variance * (sqrt(2.0 * PI))) * exp(0.0 - (square(value - mean)/square(variance))/ 2.0)
      return density
    
    case Uniform(lower, upper) => 
      if(lower < value && value < upper){ 1.0 / (upper - lower)}
      else {0.0}
    
    case Beta(alpha, beta) =>
      val density = (gamma(alpha + beta)/(gamma(alpha) * gamma(beta))) * pow(value, (alpha - 1.0)) * pow((value - 1.0), (beta - 1.0))
      return density
  }
}

// default Sample und Observe handler
def handleSample[R]{program: () => R / Sample} = {
  try {program()}
  with Sample {(dist) => resume(draw(dist))}
}

def handleObserve[R]{program: () => R / Observe} = {
  try {program()}
  with Observe {(value, dist) => do Weight(density(value, dist)); resume(())}
}

def handleRandom[R]{program: () => R / Random}: R = {
  try {program()}
  with Random {() => resume(random())}
}

//rejection sampling
def handleWeight[R]{program: () => R / Weight}: R / Random = {
  try {program()}
  with Weight {(prob) => 
    if(do Random() < prob) {resume(())}
    else {handleWeight{program}}
  }
}

//rename
def handleWeight2[R]{program: () => R / Weight}: (R, Double)  = {
  var current = 1.0
  try {(program(), current)}
  with Weight {(prob) =>
    current = current * prob;
    resume(())}
}

//Metropolis Hastings auxiliary definitions and inference Operations
// wenn sample dann nächstes element sonst panic("message")
def handleReusingTrace[R](trace0: Trace){program: () => R / Sample} = {
  var trace = trace0
  try {program()}
  with Sample {(dist) =>
    trace match {
      case Nil() => panic("empty trace")
      case Cons(t, ts) => trace = ts; resume(t) 
    }
  }
}

// wenn sample dann sample + in trace speichern
//resune nach cons -> falsche reihenfolge
//def handleTracing[R]{program: () => R / Sample}: (R, Trace) / Sample = {
//  var trace = []
//
//  try {(program(), trace)}
//  with Sample {(dist) => 
//    val sample = do Sample(dist);
//    trace = Cons(sample, trace)
//    resume(sample);
//  }
//}

def handleTracing[R]{program: () => R / Sample}: (R, Trace) / Sample = {
  try {(program(), [])}
  with Sample {(dist) => 
    val d = do Sample(dist);
    val (r, trace) = resume(d);
    (r, Cons(d, trace))
  }
}

def handleEmit[A,R]{program: () => R / Emit[A]} = {
  try {program()}
  with Emit[A] {
    def emit(element) = {println(element); resume(())}}
}

def handleLimitEmit[A,R](n: Int){program: () => R / Emit[A]} = {
  var steps = n
  try {program(); ()}
  with Emit[A] {
    def emit(element) = {
      println(element)
      steps = steps - 1
      if (0 < steps) {resume(())}
    }
  }
}

//generatin proposal by adding gausain noise(normal noise)
// adding noise to all rekursiv
def propose(trace: Trace): Trace / Sample = {
  trace match {
    case Nil() => [] 
    case Cons(t, ts) => 
      val noise = do Sample(Gaussian(0.0, 1.0))
      val proposal = t + noise
      Cons(proposal, propose(ts)) 
  }
}


// 1 iteration/step of Metropolis-Hastings algorithm
def metropolisStep[A](prob0: Probability, trace0: Trace){program: Trace => (A, Probability)} = {
  val trace1 = propose(trace0)
  val (result1, prob1) = program(trace1)

  if(prob1 < prob0){
    do Weight(prob1 / prob0)
  }
  ((result1, trace1), prob1)
}

def metropolisHastings[A]{program: () => A / {Sample, Weight}} = {
  val ((result0, trace0), prob0) = handleWeight2{
    handleRandom{
      handleSample{
        handleTracing{
          program()
        }
      }
    }
  }

  var nextprob = prob0
  var nexttrace = trace0
  var nextresult = result0

  //n mal metropolis step um nächste trace & prob zu bekommen
  //handleWeight bei jedem aufruf von metropolisStep
  //handleRandom handleSample auch bei jedem aufruf 
  while (true) {
    //mStep
    val ((nextresult, nexttrace), nextprob) =
    handleRandom{
      handleSample{
        handleWeight{
          metropolisStep(nextprob, nexttrace){ trace => handleWeight2 { handleReusingTrace(trace) { program() } } }
        }
      }
    }
    do emit(nextresult)
  }
}

def sliceSampling[R](){program: () => R / Weight} = {
  val (result, prob) = handleWeight2{program()}
  
  def step(result0: R, prob0: Probability) = handleWeight{
    val (result1, prob1) = handleWeight2{program()}
    if (prob1 < prob0) {do Weight(prob1 / prob0)}
    (result1, prob1)
  }

  def loop(result: R, prob: Probability): Unit / Emit[R] = {
    do emit(result)
    val (result1, prob1) = step(result, prob)
    loop(result1, prob1)
  }

  loop(result, prob)
}

def main() = {
  // testing the draw function
  //repeat(50){
  //  val dr = handleRandom{
  //    draw(Gaussian(0.0, 1.0))
  //  }
  //  println(dr)
  //}

  // testing handleReusingTrace
  //val res = handleReusingTrace([0.7, 2.1]){ () => 
  //  val a = do Sample(Gaussian(0.0, 1.0))  
  //  return a
  //}
  //println(res)
  //println("\n")

  // testing Metropolis-Hastings
  handleLimitEmit[Double,Unit](10){ metropolisHastings{() => 
      do Sample (Gaussian(0.0, 1.0))
    }
  }

  println("\n")
  // testing sliceSampling
  handleLimitEmit[Double, Unit](10){handleRandom{handleSample{sliceSampling{
    do Sample(Gaussian(0.0, 1.0))
  }}}}

}