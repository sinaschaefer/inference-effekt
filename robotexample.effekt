import probs
import immutable/list

record State(x: Double, y: Double, vx: Double, vy: Double)

type Measurement = Double

// movement of the robot in one time intervall
def move(s: State): State / Sample = {
  s match {
    case State(x, y, vx, vy) =>
      val xa = do Sample(Gaussian(0.0, 1.0))
      val ya = do Sample(Gaussian(0.0, 1.0))
      return State(x+vx+xa, y+vy+ya, vx+xa, vy+ya)
  }
}

// measures distance to robot and observes how probable position is given current state
def measure(s: State, m: Measurement): Unit / Observe = {
  s match {
    case State(x, y, vx, vy) =>
      val dist = sqrt(square(x) + square(y))
      do Observe(m, Gaussian(dist, 0.4))
  }
}

// approximates next step based on current position and next distance measurement
def step(s0: State, m1: Measurement): State / {Sample,Observe} = {
  val se = move(s0)
  measure(se, m1)
  return se
}

def main() = {
  val start = timestamp()

  println("testing with rejectionSampling")
  handleLimitEmit[State, Unit](5){rejectionSampling[State]{
    val init = State(0.0, 3.0, 2.0, 0.0)
    step(init, 5.0)
  }}
  val t0 = timestamp()
  println(t0 - start)
  
  println("\ntesting with slice sampling wrapper")
  handleLimitEmit[State, Unit](5){
    sliceSamplingWrap[State]{
      val init = State(0.0, 3.0, 2.0, 0.0)
      step(init, 5.0)
    }
  }
  val t1 = timestamp()
  println(t1 - t0)
  println("\n")

  handleLimitEmit[State, Unit](1){sliceSamplingWrap[State]{
    var nextState = State(0.0, 3.0, 2.0, 0.0)
    var nextdis = 5.0
    var m = 5

    while(m > 0){
      nextState = step(nextState, nextdis)
      val noise = do Sample(Gaussian(0.0, 1.0))
      nextdis = nextdis + noise
      println (nextState)
      m = m - 1
    }
    return nextState
  }}
  val t2 = timestamp() 
  println(t2 - t1)

  // testing robot with MH and multiple steps
  println("\ntesting with metropolis hasting wrapper")
  handleLimitEmit[State, Unit](1){metropolisHastingsWrap[State]{
    var nextState = State(0.0, 3.0, 2.0, 0.0)
    var nextdis = 5.0
    var m = 5
    
    while(m > 0){
      nextState = step(nextState, nextdis)
      val noise = do Sample(Gaussian(0.0, 1.0))
      nextdis = nextdis + noise
      println (nextState)
      m = m - 1
    }
    return nextState
  }}
  val t3 = timestamp()
  println(t3 - t2)

  println("\ntesting with metropolis hastings single site wrapper")
  handleLimitEmit[State, Unit](1){metropolisHastingsSingleSiteWrap[State]{
    var nextState = State(0.0, 3.0, 2.0, 0.0)
    var nextdis = 5.0
    var m = 5
    
    while(m > 0){
      nextState = step(nextState, nextdis)
      val noise = do Sample(Gaussian(0.0, 1.0))
      nextdis = nextdis + noise
      println (nextState)
      m = m - 1
    }
    return nextState
  }}
  val t4 = timestamp()
  println(t4 - t3)
}