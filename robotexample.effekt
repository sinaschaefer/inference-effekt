import probs
import immutable/list

record State(x: Double, y: Double, vx: Double, vy: Double)

type Measurement = Double

// movement of the robot in one time intervall
def move(s: State): State / Sample = {
  s match {
    case State(x, y, vx, vy) =>
      val xa = do Sample(Gaussian(0.0, 1.0))
      val ya = do Sample(Gaussian(0.0, 1.0))
      return State(x+vx+xa, y+vy+ya, vx+xa, vy+ya)
  }
}

// measures distance to robot and observes how probable position is given current state
def measure(s: State, m: Measurement): Unit / Observe = {
  s match {
    case State(x, y, vx, vy) =>
      val dist = sqrt(square(x) + square(y))
      do Observe(m, Gaussian(dist, 0.4))
  }
}

// approximates next step based on current position and next distance measurement
def step(s0: State, m1: Measurement): State / {Sample,Observe} = {
  val se = move(s0)
  measure(se, m1)
  return se
}

def main() = {
  handleLimitEmit[State, Unit](10){handleRandom{handleSample{sliceSampling[State]{handleObserve{
    val init = State(0.0, 3.0, 2.0, 0.0)
    step(init, 5.0)
  }}}}}
  
  println("\n")

  println("\n")

  handleLimitEmit[State, Unit](1){handleRandom{handleSample{sliceSampling[State]{handleObserve{
    var nextState = State(0.0, 3.0, 2.0, 0.0)
    var nextdis = 5.0
    var m = 2

    while(m > 0){
      nextState = step(nextState, nextdis)
      val noise = do Sample(Gaussian(0.0, 1.0))
      nextdis = nextdis + noise
      println (nextState)
      m = m - 1
    }
    return nextState
  }}}}}

  // testing robot with MH and multiple steps
  println("\n testing 'new' MH version:")
  handleLimitEmit[State, Unit](1){metropolisHastings[State]{handleObserve{
    var nextState = State(0.0, 3.0, 2.0, 0.0)
    var nextdis = 5.0
    var m = 5
    
    while(m > 0){
      nextState = step(nextState, nextdis)
      val noise = do Sample(Gaussian(0.0, 1.0))
      nextdis = nextdis + noise
      println (nextState)
      m = m - 1
    }
    return nextState
  }}}
}